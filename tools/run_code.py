"""Python code execution tool with automatic debugging context."""

import logging
import os
import subprocess

from langchain_core.tools import tool

logger = logging.getLogger(__name__)


def strip_code_fences(code: str) -> str:
    code = code.strip()
    # Remove ```python ... ``` or ``` ... ```
    if code.startswith("```"):
        # remove first line (```python or ```)
        code = code.split("\n", 1)[1]
    if code.endswith("```"):
        code = code.rsplit("\n", 1)[0]
    return code.strip()


@tool
def run_code(code: str) -> dict:
    """
    Executes Python code in an isolated environment with automatic dependency management.

    **When to Use:**
    - Data analysis (CSV, JSON processing)
    - Mathematical calculations
    - String manipulation/decoding
    - Algorithm implementation
    - File processing after download_file()

    **Execution Environment:**
    - Runs INSIDE 'LLMFiles/' directory
    - Has access to all files downloaded via download_file()
    - Fresh Python process each time (variables don't persist)
    - 30-second timeout limit
    - Uses 'uv run' for fast execution

    **Critical File Access Rule:**
    When accessing downloaded files, use FILENAME ONLY, not full path:
    ```
    âœ“ Correct:   df = pd.read_csv('data.csv')
    âœ“ Correct:   img = Image.open('photo.jpg')

    âœ— Wrong:     df = pd.read_csv('LLMFiles/data.csv')
    âœ— Wrong:     img = Image.open('./LLMFiles/photo.jpg')
    ```

    **Common Patterns:**

    1. **Data Analysis:**
    ```python
    import pandas as pd
    df = pd.read_csv('data.csv')
    result = df['column'].sum()
    print(result)
    ```

    2. **String Decoding:**
    ```python
    import base64
    decoded = base64.b64decode('SGVsbG8=').decode()
    print(decoded)
    ```

    3. **Mathematical Computation:**
    ```python
    import math
    answer = math.factorial(10) + 42
    print(answer)
    ```

    **Auto-Debugging:**
    If your code fails, stderr will include:
    - List of files available in the working directory
    - Working directory path
    - Hint about file access (if FileNotFoundError)

    **Missing Libraries:**
    If you get "ModuleNotFoundError", use add_dependencies() first:
    ```
    add_dependencies("pandas numpy")
    # Then run your code
    run_code("import pandas as pd; ...")
    ```

    Args:
        code: Python code to execute (can include markdown fences)

    Returns:
        dict: {
            'stdout': str,  # Program output (truncated at 5000 chars)
            'stderr': str,  # Error messages with debugging context
            'return_code': int,  # 0 = success, non-zero = error
            'files_created': list  # New files generated by your code
        }

    Tips:
    - Always print() your final answer
    - Use descriptive variable names for debugging
    - Check stderr if return_code != 0
    - For large outputs, write to a file and read it separately
    """
    try:
        clean_code = strip_code_fences(code)

        # Ensure working directory exists
        work_dir = "LLMFiles"
        os.makedirs(work_dir, exist_ok=True)

        # Track files before execution
        files_before = set(os.listdir(work_dir))

        # Write code to temporary file
        code_file = os.path.join(work_dir, "runner.py")
        with open(code_file, "w", encoding="utf-8") as f:
            f.write(clean_code)

        logger.info("ðŸ’» EXECUTING Python Code...")
        logger.info(f"   Code length: {len(clean_code)} chars")

        # Execute code
        proc = subprocess.Popen(
            ["uv", "run", "runner.py"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            cwd=work_dir,
        )

        try:
            stdout, stderr = proc.communicate(timeout=30)
        except subprocess.TimeoutExpired:
            proc.kill()
            logger.error("âŒ Code Execution Timeout (30s)")
            return {
                "error": "Execution timed out after 30 seconds",
                "suggestion": "Optimize your code or break it into smaller steps",
                "return_code": -1,
            }

        # Track new files created
        files_after = set(os.listdir(work_dir))
        files_created = list(files_after - files_before - {"runner.py"})

        # Enhanced error context
        if proc.returncode != 0 or stderr:
            files_in_dir = [f for f in os.listdir(work_dir) if f != "runner.py"]

            debug_context = "\n\n=== DEBUGGING CONTEXT ===\n"
            debug_context += f"Working Directory: {work_dir}\n"
            debug_context += f"Available Files: {files_in_dir}\n"

            # Specific hints based on error type
            if "FileNotFoundError" in stderr or "No such file" in stderr:
                debug_context += "\nâš ï¸ FILE ACCESS ERROR:\n"
                debug_context += "   Your code runs INSIDE LLMFiles/\n"
                debug_context += (
                    "   Use filename only: 'data.csv' not 'LLMFiles/data.csv'\n"
                )
            elif "ModuleNotFoundError" in stderr:
                debug_context += "\nâš ï¸ MISSING LIBRARY:\n"
                debug_context += (
                    "   Use add_dependencies() to install required packages\n"
                )
                match = re.search(r"No module named '(\w+)'", stderr)
                if match:
                    debug_context += (
                        f"   Example: add_dependencies('{match.group(1)}')\n"
                    )

            stderr += debug_context
            logger.error(f"âŒ Code Error: {stderr[:200]}...")
        else:
            logger.info(f"âœ… Code Success: {stdout[:100]}...")

        # Truncate large outputs
        if len(stdout) > 5000:
            stdout = stdout[
                :5000
            ] + "\n\n...[OUTPUT TRUNCATED - Total length: {} chars]".format(len(stdout))
        if len(stderr) > 5000:
            stderr = stderr[:5000] + "\n\n...[ERROR LOG TRUNCATED]"

        return {
            "stdout": stdout,
            "stderr": stderr,
            "return_code": proc.returncode,
            "files_created": files_created,
            "success": proc.returncode == 0,
        }

    except Exception as e:
        logger.error(f"ðŸ’¥ Code Execution Failed: {e}")
        return {
            "error": str(e),
            "suggestion": "Check code syntax and try again",
            "return_code": -1,
        }

